// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3824.PrototypeRobot.subsystems;

import org.usfirst.frc3824.PrototypeRobot.RobotMap;
import org.usfirst.frc3824.PrototypeRobot.commands.*;

import edu.wpi.first.wpilibj.SPI;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class TargetCam extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


    // Put methods for controlling this subsystem
    // here. Call these from Commands.
	public class TargetObject{
		public int x;
		public int y;
		public int width;
		public int height;
	}
	
	private static int kPIXY_ARRAYSIZE = 5;
	private static int kPIXY_START_WORD = 0xaa55;
	private static int kPIXY_START_WORDX = 0x55aa;
	private SPI pixySPI;
	private TargetObject[] blocksFound;
	
	public TargetCam()
	{
		pixySPI = new SPI(SPI.Port.kOnboardCS0);
	}
	
    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    private int getWord()
    {
    	int result;
    	byte[] dataReceived = new byte[2];
   	
    	if(0 != pixySPI.read(true, dataReceived, 2))
    	{
    		result = dataReceived[1] << 8 | dataReceived[0];
    	}
    	else
    	{
    		result = 0;
    	}
    	
    	return result;
    }
    
    public TargetObject[] getObjectsInFrame()
    {
    	int w;
    	int lastw = 0xffff;
    	boolean fFrameFound = false;
    	int blockCount;
    	int checksum;
    	byte[] dummy = new byte[1];
    	int sum;
    	
    	while(!fFrameFound)
    	{
            w = getWord();
            
            if (w==0 && lastw==0) {
            	return null; // in I2C and SPI modes this means no data, so return immediately
            }  
            else if (w==kPIXY_START_WORD && lastw==kPIXY_START_WORD)
            {
              fFrameFound = true; // code found!
            }
            else if (w==kPIXY_START_WORDX) // this is important, we might be juxtaposed
            {
            	pixySPI.read(true, dummy, 1); // we're out of sync! (backwards)
            }
            
            lastw = w; // save
    	}
    	
    	
    	for(blockCount=0; blockCount<kPIXY_ARRAYSIZE;)
    	  {
    	    checksum = getWord();
    	    if (checksum==kPIXY_START_WORD) // we've reached the beginning of the next frame
    	    {
    	      return blocksFound;
    	    }
    	    else if (checksum==0)
    	      return blocksFound;

    	    // dummy read to skip the signature number
    	    sum = getWord();
    	    
    	    // read in the data we care about
    	    blocksFound[blockCount].x = getWord(); sum += blocksFound[blockCount].x;
    	    blocksFound[blockCount].y = getWord(); sum += blocksFound[blockCount].y;
    	    blocksFound[blockCount].width = getWord(); sum += blocksFound[blockCount].width;
    	    blocksFound[blockCount].height = getWord(); sum += blocksFound[blockCount].height;

    	    // check checksum
    	    if (checksum==sum)
    	      blockCount++;
    	    else
    	      System.out.println("checksum error in getting pixy data!");

    	    w = getWord();
    	    if (w != kPIXY_START_WORD){
    	    	break;
    	    }
    	  }

    	
    	return blocksFound;
    }
    
}

